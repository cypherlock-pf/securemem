package despectre

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha512"
	"github.com/cypherlock-pf/securemem/guardedmem"
	"io"
)

// guard is a list of pages containing random data (generated by encrypting the contents with a random key)
type guard struct {
	next *guard
	data [guardSize]byte
}

// generate the hash of the guard page contents.
func (g *guard) hash(d []byte) []byte {
	var next *guard
	h := sha512.New512_256()
	next = g
	for {
		if next == nil {
			break
		}
		h.Write(next.data[:])
		next = next.next
	}
	_ = h.Sum(d[0:0])
	return d
}

// randomize the guard page contents by encrypting them.
func (g *guard) randomize(d *[randKeySize]byte, s cipher.Stream) {
	var iv [randKeySize]byte
	if g == nil {
		return
	}
	if s == nil {
		c, err := aes.NewCipher(d[:])
		if err != nil {
			panic(err)
		}
		if _, err := io.ReadFull(rand.Reader, iv[:]); err != nil {
			panic(err)
		}
		s = cipher.NewCTR(c, iv[:])
	}
	s.XORKeyStream(g.data[:], g.data[:])
	if g.next != nil {
		g.next.randomize(nil, s)
	}
	if d != nil {
		setZero(iv[:])
		setZero(d[:])
	}
}

// free a list of guards.
func (g *guard) free() {
	if g == nil {
		return
	}
	if g.next != nil {
		g.next.free()
	}
	setZero(g.data[:])
	_ = guardedmem.Free(g)
}

// allocate a list of guards and randomize them.
func allocGuard(size int, tkey *[randKeySize]byte) (*guard, error) {
	var prev, c, r *guard
	var err error
	count := size / guardSize
	if size%guardSize != 0 {
		count++
	}
	for i := 0; i < count; i++ {
		c, err = guardedmem.Alloc(guard{})
		if err != nil {
			if r != nil {
				r.free()
			}
			r = nil
			return nil, err
		}
		if prev != nil {
			prev.next = c
		} else {
			r = c
		}
		prev = c
	}
	r.randomize(tkey, nil)
	return r, nil
}
